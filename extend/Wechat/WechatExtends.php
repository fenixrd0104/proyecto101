<?php

namespace Wechat;

use Wechat\Lib\Common;
use Wechat\Lib\Tools;

/**
 * WeChat extension function
  *
  * @author Anyon <zoujingli@qq.com>
  * @date 2016-08-22 10:32
  */
 class WechatExtends extends Common {
 
     const QR_LIMIT_SCENE = 1;
 
     /** Semantic understanding */
     const SEMANTIC_API_URL = '/semantic/semproxy/search?';
     const QRCODE_IMG_URL = 'https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=';
     const QRCODE_CREATE_URL = '/qrcode/create?';
     const SHORT_URL = '/shorturl?';
     const QR_SCENE = 0;
 
     /** Data analysis interface */
     static $DATACUBE_URL_ARR = array(//User analysis
         'user' => array(
             'summary' => '/datacube/getusersummary?', //Get user increase and decrease data (getusersummary)
             'cumulate' => '/datacube/getusercumulate?', //Get accumulated user data (getusercumulate)
         ),
         'article' => array(//Graphic and text analysis
             'summary' => '/datacube/getarticlesummary?', //Get the daily data of graphic and text group (getarticlesummary)
             'total' => '/datacube/getarticletotal?', //Get the total data of the graphic and text group (getarticletotal)
             'read' => '/datacube/getuserread?', //Get graphic statistics (getuserread)
             'readhour' => '/datacube/getuserreadhour?', //Get graphic and text statistics time-sharing data (getuserreadhour)
             'share' => '/datacube/getusershare?', //Get image and text sharing forwarding data (getusershare)
             'sharehour' => '/datacube/getusersharehour?', //Get image sharing and forwarding time-sharing data (getusersharehour)
        ),
        'upstreammsg' => array(//Message analysis
            'summary' => '/datacube/getupstreammsg?', //Get message sending summary data (getupstreammsg)
            'hour' => '/datacube/getupstreammsghour?', //Get message distribution time division data (getupstreammsghour)
            'week' => '/datacube/getupstreammsgweek?', //Get message sending week data (getupstreammsgweek)
            'month' => '/datacube/getupstreammsgmonth?', //Get message sending month data (getupstreammsgmonth)
            'dist' => '/datacube/getupstreammsgdist?', //Get message sending distribution data (getupstreammsgdist)
            'distweek' => '/datacube/getupstreammsgdistweek?', //Get message sending distribution week data (getupstreammsgdistweek)
            'distmonth' => '/datacube/getupstreammsgdistmonth?', //Get message sending distribution month data (getupstreammsgdistmonth)
        ),
        'interface' => array(//Interface analysis
            'summary' => '/datacube/getinterfacesummary?', //Get interface analysis data (getinterfacesummary)
            'summaryhour' => '/datacube/getinterfacesummaryhour?', //Get interface analysis time-sharing data (getinterfacesummaryhour)
        )
    );

    /**
     * Get QR code picture
     * @param string $ticket Pass in the ticket parameter generated by the getQRCode method
     * @return string url returns the http address
     */
    public function getQRUrl($ticket) {
        return self::QRCODE_IMG_URL .urlencode($ticket);
    }

    /**
     * Long link to short link interface
     * @param string $long_url pass in the long url to convert
     * @return bool|string url If successful, return the converted short url
     */
    public function getShortUrl($long_url) {
        if (!$this->access_token && !$this->getAccessToken()) {
            return false;
        }
        $data = array(
            'action'   => 'long2short',
            'long_url' => $long_url
        );
        $result = Tools::httpPost(self::API_URL_PREFIX . self::SHORT_URL . "access_token={$this->access_token}", Tools::json_encode($data));
        if ($result) {
            $json = json_decode($result, true);
            if (!$json || !empty($json['errcode'])) {
                $this->errCode = $json['errcode'];
                $this->errMsg = $json['errmsg'];
                return $this->checkRetry(__FUNCTION__, func_get_args());
            }
            return $json['short_url'];
        }
        return false;
    }

    /**
     * Create a QR code ticket
     * @param int|string $scene_id Custom tracking id, temporary QR code can only use numeric type
     * @param int $type 0: temporary QR code; 1: permanent QR code (the expire parameter is invalid at this time); 2: permanent QR code (the expire parameter is invalid at this time)
     * @param int $expire Temporary QR code validity period, the maximum is 2592000 seconds (30 days)
     * @return bool|array ('ticket'=>'qrcode string','expire_seconds'=>2592000,'url'=>'QR code image parsed address')
     */
    public function getQRCode($scene_id, $type = 0, $expire = 2592000) {
        if (!$this->access_token && !$this->getAccessToken()) {
            return false;
        }
        $type = ($type && is_string($scene_id)) ? 2 : $type;
        $data = array(
            'action_name'    => $type ? ($type == 2 ? "QR_LIMIT_STR_SCENE" : "QR_LIMIT_SCENE") : "QR_SCENE",
            'expire_seconds' => $expire,
            'action_info'    => array('scene' => ($type == 2 ? array('scene_str' => $scene_id) : array('scene_id' => $scene_id)))
        );
        if ($type == 1) {
            unset($data['expire_seconds']);
        }
        $result = Tools::httpPost(self::API_URL_PREFIX . self::QRCODE_CREATE_URL . "access_token={$this->access_token}", Tools::json_encode($data));
        if ($result) {
            $json = json_decode($result, true);
            if (!$json || !empty($json['errcode'])) {
                $this->errCode = $json['errcode'];
                $this->errMsg = $json['errmsg'];
                return $this->checkRetry(__FUNCTION__, func_get_args());
            }
            return $json;
        }
        return false;
    }

    /**
    * Semantic understanding interface
     * @param string $uid The user's unique id (non-developer id), the user distinguishes different users under the official account (recommended to fill in the user's openid)
     * @param string $query input text string
     * @param string $category The service type to be used, multiple separated by ",", cannot be empty
     * @param float $latitude Latitude coordinate, passed in at the same time as longitude; pass in either city or city
     * @param float $longitude longitude coordinates, passed in at the same time as latitude; passed in either with city
     * @param string $city city name, select one of latitude and longitude
     * @param string $region The name of the region, which can be omitted if the city exists; select one of the latitude and longitude to pass in
     * @return bool|array
     */
    public function querySemantic($uid, $query, $category, $latitude = 0.00, $longitude = 0.00, $city = "", $region = "") {
        if (!$this->access_token && !$this->getAccessToken()) {
            return false;
        }
        $data = array(
            'query'    => $query,
            'category' => $category,
            'appid'    => $this->appid,
            'uid'      => ''
        );
        //Choose either geographic coordinates or city name
        if ($latitude) {
            $data['latitude'] = $latitude;
            $data['longitude'] = $longitude;
        } elseif ($city) {
            $data['city'] = $city;
        } elseif ($region) {
            $data['region'] = $region;
        }
        $result = Tools::httpPost(self::API_BASE_URL_PREFIX . self::SEMANTIC_API_URL . "access_token={$this->access_token}", Tools::json_encode($data));
        if ($result) {
            $json = json_decode($result, true);
            if (!$json || !empty($json['errcode'])) {
                $this->errCode = $json['errcode'];
                $this->errMsg = $json['errmsg'];
                return $this->checkRetry(__FUNCTION__, func_get_args());
            }
            return $json;
        }
        return false;
    }

    /**
    * Get statistics
     * @param string $type Data classification (user|article|upstreammsg|interface) are (user analysis|graphics analysis|message analysis|interface analysis)
     * @param string $subtype Data subcategory, refer to DATACUBE_URL_ARR constant definition section or README.md documentation
     * @param string $begin_date start time
     * @param string $end_date end time
     * @return bool|array Successfully returns the query result array, please refer to the official documentation for its definition
     */
    public function getDatacube($type, $subtype, $begin_date, $end_date = '') {
        if (!$this->access_token && !$this->getAccessToken()) {
            return false;
        }
        if (!isset(self::$DATACUBE_URL_ARR[$type]) || !isset(self::$DATACUBE_URL_ARR[$type][$subtype])) {
            return false;
        }
        $data = array(
            'begin_date' => $begin_date,
            'end_date'   => $end_date ? $end_date : $begin_date
        );
        $result = Tools::httpPost(self::API_BASE_URL_PREFIX . self::$DATACUBE_URL_ARR[$type][$subtype] . "access_token={$this->access_token}", Tools::json_encode($data));
        if ($result) {
            $json = json_decode($result, true);
            if (!$json || !empty($json['errcode'])) {
                $this->errCode = $json['errcode'];
                $this->errMsg = $json['errmsg'];
                return $this->checkRetry(__FUNCTION__, func_get_args());
            }
            return isset($json['list']) ? $json['list'] : $json;
        }
        return false;
    }

}
